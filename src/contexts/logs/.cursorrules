# Logs Context Development Rules

## Overview
This folder contains the virtual logs system for IPFS WebUI, providing efficient real-time log viewing with virtual scrolling capabilities. The system handles high-volume log streaming while maintaining smooth UI performance.

## Architecture Components

### Core Files
- `logs-context.tsx` - Main React context provider and state management
- `batch-processor.ts` - Optimizes incoming log streams with batching and rate monitoring
- `reducer.ts` - State management with immutable updates
- `types.ts` - TypeScript interfaces and type definitions
- `api.ts` - IPFS log API interactions
- `index.ts` - Clean exports for the context

### Integration Points
- `src/hooks/use-virtual-logs.ts` - Virtual scrolling hook
- `src/components/logs/virtual-logs-viewer.tsx` - Main UI component
- `src/lib/log-storage.ts` - IndexedDB persistent storage

## Development Guidelines

### State Management
- **Use the reducer pattern**: All state changes go through `logsReducer`
- **Immutable updates**: Never mutate state directly, always return new objects
- **Action types**: Use descriptive action types with proper payloads
- **Lazy initialization**: Use `initLogsState()` for performance

### Performance Considerations
- **Batch processing**: Always batch log entries to prevent UI blocking
- **Rate monitoring**: Monitor log rates and auto-disable if too high
- **Virtual scrolling**: Use `idbIdDiff` for efficient index mapping
- **Memoization**: Use `useCallback` and `useMemo` for expensive operations

### TypeScript Requirements
- **Strict typing**: No `any` types allowed
- **Interface definitions**: Define clear interfaces in `types.ts`
- **Generic constraints**: Use proper generic constraints for reusable components
- **Type guards**: Implement type guards for runtime type checking

### Log Storage Integration
- **Circular buffer**: Respect the circular buffer behavior of IndexedDB
- **ID mapping**: Use `idbIdDiff` for virtual scrolling index calculations
- **Error handling**: Handle storage errors gracefully with fallbacks
- **Async operations**: All storage operations are async, handle properly

### Batch Processing Rules
- **Batch size**: Default 50 entries per batch
- **Time threshold**: 500ms timeout for low-volume streams
- **Rate limits**: Monitor and respect rate thresholds
- **Storage persistence**: Always store logs in IndexedDB

### Virtual Scrolling Integration
- **Index mapping**: Use `idbIdDiff` to map virtual indices to actual log IDs
- **Load more rows**: Implement efficient `loadMoreRows` function
- **Row loading**: Use `isRowLoaded` to determine if data is available
- **Entry retrieval**: Implement `getEntryAtIndex` for efficient data access

## Code Patterns

### Context Provider Pattern
```typescript
const LogsProvider: React.FC<LogsProviderProps> = ({ children, ipfs, ipfsConnected }) => {
  const [state, dispatch] = useReducer(logsReducer, undefined, initLogsState)

  // Memoized actions to prevent unnecessary re-renders
  const actions = useMemo(() => ({
    startStreaming,
    stopStreaming,
    // ... other actions
  }), [/* dependencies */])

  const contextValue = useMemo(() => ({
    ...state,
    ...actions
  }), [state, actions])

  return (
    <LogsContext.Provider value={contextValue}>
      {children}
    </LogsContext.Provider>
  )
}
```

### Batch Processing Pattern
```typescript
const processBatch = useCallback(async () => {
  const entries = [...pendingEntriesRef.current]
  pendingEntriesRef.current = []

  // Update rate monitoring
  updateRateCalculations(entries.length)

  // Store in IndexedDB
  await logStorage.appendLogs(entries)

  // Notify context
  onBatch(entries)
}, [onBatch, bufferConfig, onRateUpdate])
```

### Virtual Scrolling Pattern
```typescript
const loadMoreRows = useCallback(({ startIndex, stopIndex }) => {
  const expectedStartIndex = idbIdDiff + startIndex
  const expectedEndIndex = idbIdDiff + stopIndex

  const entries = await logStorage.getLogIdRange(expectedStartIndex, expectedEndIndex)
  setDisplayEntries(entries)
}, [idbIdDiff, setDisplayEntries])
```

## Error Handling

### Streaming Errors
- Catch and handle IPFS connection errors
- Implement automatic retry mechanisms
- Provide user feedback for persistent failures
- Graceful degradation when IPFS unavailable

### Storage Errors
- Handle IndexedDB quota exceeded
- Implement fallback to memory-only mode
- Recover from corrupted data gracefully
- Log errors for debugging

### Performance Errors
- Auto-disable streaming on high rates
- Show warnings for performance issues
- Implement adaptive batching
- Monitor memory usage

## Testing Guidelines

### Unit Tests
- Test reducer actions independently
- Mock IndexedDB for storage tests
- Test batch processing logic
- Verify type safety

### Integration Tests
- Test context provider integration
- Test virtual scrolling with mock data
- Test streaming with mock IPFS
- Test error scenarios

### Performance Tests
- Test with high-volume log streams
- Verify virtual scrolling performance
- Test memory usage under load
- Monitor rate limiting behavior

## Configuration

### Buffer Configuration
```typescript
const DEFAULT_BUFFER_CONFIG: LogBufferConfig = {
  memory: 100,              // Max entries in memory
  indexedDB: 200_000,       // Max entries in storage
  warnThreshold: 50,        // Rate warning threshold
  autoDisableThreshold: 1_000 // Auto-disable threshold
}
```

### Rate Monitoring
- Track entries per second over 5-second window
- Warn when rate exceeds `warnThreshold`
- Auto-disable when rate exceeds `autoDisableThreshold`
- Provide user feedback for rate issues

## Debugging

### Debug Logging
```typescript
console.log('Virtual logs debug info:', {
  displayEntries: displayEntries.length,
  rowCount,
  idbIdDiff,
  isStreaming,
  hasMoreHistory
})
```

### Performance Monitoring
- Monitor batch processing frequency
- Track memory usage patterns
- Monitor IndexedDB performance
- Track virtual scrolling efficiency

## Migration Notes

### From Redux Bundler
- This context replaces redux-bundler patterns
- Use React Context for state management
- Implement proper TypeScript types
- Follow the migration guide in `src/helpers/REDUX-BUNDLER-MIGRATION-GUIDE.md`

### Breaking Changes
- Virtual scrolling replaces simple list rendering
- Batch processing replaces immediate updates
- IndexedDB storage replaces memory-only storage
- Rate monitoring replaces simple streaming

## Future Considerations

### Planned Enhancements
- Web Workers for background processing
- Log compression for increased capacity
- Advanced filtering and search
- Export functionality
- Custom view configurations

### Performance Targets
- Handle 10,000+ logs/second without UI blocking
- Support 1M+ stored logs with sub-second queries
- Maintain 60fps scrolling with 100,000+ visible logs
- Efficient memory usage under load

## Documentation
- Keep `README.md` updated with architecture changes
- Document new features and APIs
- Maintain troubleshooting guides
- Update performance benchmarks

Remember: This system is designed for high-performance log viewing. Always consider the impact of changes on streaming performance, memory usage, and user experience.
